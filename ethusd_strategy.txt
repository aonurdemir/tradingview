//@version=6
strategy("ETH/USD DCA Cycle (Single Spot, same-bar fills, v6)",
     overlay=true,
     initial_capital=100,
     currency=currency.USD,
     pyramiding=100,                  // scale-in on the same position
     calc_on_order_fills=true,
     calc_on_every_tick=true,         // intrabar evaluation
     process_orders_on_close=true)    // <-- allow same-bar limit fills

// ===== Inputs =====
drop_pct_input    = input.float(1.5, "Drop % per entry", step=0.1, minval=0.1)
take_pct_input    = input.float(2.0, "Take Profit % above avg", step=0.1, minval=0.1)
max_entries       = input.int(10, "Max entries per cycle", minval=1, maxval=100)
initial_cash      = input.float(100.0, "Cycle starting cash (USD)", minval=1.0)
catch_up          = input.bool(true, "Catch up multiple steps on same bar (gap down)")
start_date        = input.time(timestamp("2024-01-01T00:00:00"), "Start Trading From")
end_date          = input.time(timestamp("2030-01-01T23:59:59"), "Stop Trading At")
use_manual_anchor = input.bool(false, "Use Manual Anchor Price?")
manual_anchor     = input.float(2000.0, "Manual Anchor Price", step=0.1)

// Fractions
drop_pct = drop_pct_input / 100.0
take_pct = take_pct_input / 100.0

// ===== State =====
var float anchor       = na
var int   steps_filled = 0
var bool  anchor_set   = false

// ===== Helpers =====
qty_for_price(p) =>
    cash_per_entry = initial_cash / max_entries
    cash_per_entry / p

// ===== Date filter =====
in_date_range = time >= start_date and time <= end_date

// ===== Initialize anchor at first eligible bar =====
if in_date_range and not anchor_set
    anchor     := use_manual_anchor ? manual_anchor : close
    anchor_set := true

// ===== Core logic (SINGLE position that grows) =====
if in_date_range and anchor_set
    // Scale-in entries
    remaining = max_entries - steps_filled
    if remaining > 0
        if catch_up
            // Try to fill multiple rungs this bar, rebasing after each fill
            for _ = 0 to remaining - 1
                next_step_price = anchor * (1 - drop_pct)
                // Only place/assume fill if today's low touched that limit
                if low <= next_step_price
                    strategy.entry("LONG", strategy.long,qty = qty_for_price(next_step_price),limit = next_step_price)
                    
                    // Rebase anchor to the filled price so the NEXT rung is another -drop_pct
                    anchor       := next_step_price
                    steps_filled += 1
                else
                    break
        else
            // One rung per bar max
            next_step_price = anchor * (1 - drop_pct)
            if low <= next_step_price
                strategy.entry("LONG", strategy.long,                    qty   = qty_for_price(next_step_price),                    limit = next_step_price)
                anchor       := next_step_price
                steps_filled += 1

    // Take-profit: sell the entire scaled position at +take_pct over VWAP avg
    in_pos = strategy.position_size > 0
    avg    = strategy.position_avg_price
    tp_lvl = in_pos ? avg * (1 + take_pct) : na

    if in_pos
        // Single exit linked to the single entry id -> closes WHOLE position
        strategy.exit("TP_ALL", from_entry="LONG", limit=tp_lvl)

    // After a filled exit (flat), start a new cycle from exit price
    if not in_pos and strategy.closedtrades > 0
        last_exit = strategy.closedtrades.exit_price(strategy.closedtrades - 1)
        anchor       := last_exit
        steps_filled := 0

// ===== Minimal plots =====
plot(anchor_set ? anchor : na, "Anchor (moving)", color=color.gray)
plot(in_date_range and strategy.position_size > 0 ? strategy.position_avg_price : na,
     "Avg Entry", color=color.yellow, linewidth=2)
