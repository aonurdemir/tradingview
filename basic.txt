//@version=6
strategy("ETH/USD DCA (market orders, 1 buy+1 sell per bar, flat trail +2%, tick tolerance)", 
     overlay=true,
     initial_capital=100,
     currency=currency.USD,
     pyramiding=100,
     calc_on_order_fills=true)

//==== Inputs ====
drop_pct_input    = input.float(1.5, "Drop % per entry", step=0.1, minval=0.1)
take_pct_input    = input.float(2.0, "Take Profit % above avg", step=0.1, minval=0.1)
max_entries       = input.int(10, "Max entries per cycle", minval=1)
initial_cash      = input.float(100.0, "Cycle starting cash (USD)", minval=1.0)
start_date        = input.time(timestamp("2024-01-01T00:00:00"), "Start Trading From")
end_date          = input.time(timestamp("2030-01-01T23:59:59"), "Stop Trading At")
use_manual_anchor = input.bool(false, "Use Manual Anchor Price?")
manual_anchor     = input.float(2000.0, "Manual Anchor Price", step=0.1)

//==== Fractions ====
drop_pct = drop_pct_input / 100.0
take_pct = take_pct_input / 100.0
eps      = syminfo.mintick * 0.5   // tolerance for comparisons

//==== State ====
var float anchor       = na
var int   steps_filled = 0
var bool  anchor_set   = false

//==== Utility ====
qty_for_price(p) =>
    (initial_cash / max_entries) / p

//==== Date window ====
in_window = time >= start_date and time <= end_date

//==== Anchor init ====
if in_window and not anchor_set
    anchor     := use_manual_anchor ? manual_anchor : close
    anchor_set := true

//==== Per-bar guards ====
var bool did_buy  = false
var bool did_sell = false
if barstate.isnew
    did_buy  := false
    did_sell := false

//==== CORE LOGIC ====
if in_window and anchor_set
    in_pos = strategy.position_size > 0
    avg    = strategy.position_avg_price

    // --- SELL first (market) ---
    if in_pos and not did_sell
        tp_lvl = avg * (1 + take_pct)
        if high + eps >= tp_lvl
            strategy.close("LONG")     // market exit
            did_sell     := true
            steps_filled := 0
            anchor       := close      // reset anchor to execution price

    // If flat, ensure anchor synced to last exit (safety)
    if strategy.position_size == 0 and strategy.closedtrades > 0
        last_exit = strategy.closedtrades.exit_price(strategy.closedtrades - 1)
        if na(anchor)
            anchor := last_exit
        steps_filled := 0

    // While flat, trail anchor UP if price rises +2%
    if strategy.position_size == 0
        uptrail = anchor * (1 + take_pct)
        if high + eps >= uptrail
            anchor := high

    // --- BUY once per bar (market) ---
    can_buy_more = steps_filled < max_entries
    rung_price   = anchor * (1 - drop_pct)

    if can_buy_more and not did_buy and low - eps <= rung_price
        q = qty_for_price(close)           // size using current close for market fill
        strategy.entry("LONG", strategy.long, qty=q)   // market entry
        did_buy      := true
        steps_filled += 1
        anchor       := close              // move anchor to execution price

//==== Plots ====
plot(anchor_set ? anchor : na, "Anchor", color=color.gray)
plot(in_window and strategy.position_size > 0 ? strategy.position_avg_price : na,
     "Avg Entry", color=color.yellow, linewidth=2)

next_rung_vis = (anchor_set and steps_filled < max_entries) ? anchor * (1 - drop_pct) : na
next_tp_vis   = (in_window and strategy.position_size > 0) ? strategy.position_avg_price * (1 + take_pct) : na

plot(next_rung_vis, title="Next Rung", color=color.new(color.blue, 60), style=plot.style_linebr)
plot(next_tp_vis,  title="Next TP",   color=color.new(color.red, 60),  style=plot.style_linebr)
